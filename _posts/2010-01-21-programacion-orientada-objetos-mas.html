---
layout: post
title: Programación orientada a objetos más legible
date: '2010-01-21T12:11:00.000Z'
author: Yeray Darias
tags: [books, code, spanish]
modified_time: '2010-01-21T12:11:21.176Z'
---

El año pasado llegó a mis manos casi por casualidad un libro titulado <a href="http://pragprog.com/titles/twa/thoughtworks-anthology">"The Thoughtwors Antology"</a>. Mirandolo por encima, uno de sus capítulos, escrito por Jeff Bay, me llamó la atención porque daba una serie de reglas para mejorar la calidad de nuestro código orientado a objetos en muy pocas páginas. A mi me gustaría comentar algunas de estas reglas en mi blog porque considero que son bastante útiles.<br /><br />Esto no quiere decir que podamos evitar la lectura de libros (de gran calidad) dedicados al tema como puede ser <a href="http://www.amazon.com/gp/product/0132350882/ref=s9_simi_gw_s0_p14_i1?pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_s=center-2&amp;pf_rd_r=1K3CYHQKT0B97MR00CNR&amp;pf_rd_t=101&amp;pf_rd_p=470938631&amp;pf_rd_i=507846">"Clean code"</a>, pero nos permite tener una visión general para todos aquellos que no seamos expertos en la programación orientada a objetos.<br /><br /><b>Un nivel de indentación por método.</b><br /><br />Dicho así de rápido y fuera de contexto puede resultar una regla un poco dura, pero en realidad hace referencia a la necesidad de tener métodos cohesivos y que realicen una única tarea. Una de las mejores métricas que he conocido en mi breve vida de desarrollador de software es esta, porque cuando un mismo método tiene más de dos niveles de anidamiento es que está haciendo algo más de lo que debería (esto no quiere decir que se cumpla en el 100% de las veces).<br /><br /><b>No hacer uso de la palabra reservada "else".</b><br /><br />En mi experiencia de estudiante lo más importante de las prácticas es que funcionen, siempre tiene algo de importancia la calidad del código pero no se mira con mucho detalle (dependerá de la asignatura y el profesor). Pero cuando empiezas a trabajar, muchas empresas también buscan que el código sea sencillo y se entienda en una sola pasada, principalmente porque en el código trabaja más gente a parte de tí. Los bloques condicionales son una de las estructuras que más oscurecen el código fuente, por lo que es necesario simplificarlos lo mejor posible.<br /><br />Pongamos el ejemplo siguiente.<br /><br /><pre><code><br />public void deleteDocument(String docId) {<br />   Document document = getDocument(docId);<br />   if (document != null)<br />      database.delete(document);<br />   else<br />      throw new BlackboardException(...);<br />}<br /></code></pre><br />Utilizando esta regla podemos refactorizar al siguiente bloque, que en general resultará más sencillo de leer y por lo tanto de saber cual es su función (aunque el propio nombre del método debería aclararlo).<br /><br /><pre><code><br />public void deleteDocument(String docId) {<br />   Document document = getDocument(docId);<br />   if (document == null)<br />      throw new BlackboardException(...);<br /><br />   database.delete(document);<br />}<br /></code></pre><br />Hay algunos autores que incluso recomiendan <a href="http://www.antiifcampaign.com/">evitar el uso de los bloques condicionales</a>, haciendo uso de las propiedades de los objetos. Intenta hacer algunos ejercicios verás como la calidad de tú código mejora drásticamente. <br /><br /><b>Envolver todas las primitivas y strings.</b><br /><br />Esta, en mi opinión, es una regla un poco controvertida, pero es igual de cierto que es una práctica común en Domain-Driven Design (DDD) porque hace los conceptos explícitos. Hay casos en los que el uso de primitivas se entiende perfectamente bien, pero hay casos en los que el uso de objetos valor (objetos que envuelven a la primitiva, en general extendiendola) puede aclarar el modelo de dominio y además hacer que el modelo se pueda evolucionar más facilmente en el futuro.<br /><br /><b>Utilizar un solo punto (.) por línea.</b><br /><br />Aunque lo intento evitar en la medida de lo posible, es muy normal encontrar en muchos lugares de mi código cosas como ...<br /><br /><br /><pre><code><br />...<br />comprobarCodigoPostal(persona.getDireccion().getCodigoPostal());<br />...<br /></code></pre><br />Para mucha gente será obvio que no se está haciendo uso de forma correcta de la abstracción de los objetos. Sería más lógico y mucho más claro tener algo como ...<br /><br /><br /><pre><code><br />...<br />comprobarDireccion(persona.getDireccion());<br />...<br />comprobarCodigoPostal(direccion.getCodigoPostal());<br />...<br /></code></pre><br />Quizás el ejemplo no es el más claro del mundo, pero espero que se aprecie que evitando la utilización de más de una referencia por línea, el código es mucho más sencillo y manejable, además de representar su funcionalidad a primera vista.<br /><br /><b>No usar abreviaciones.</b><br /><br />Robert C. Martin escribe en su <a href="http://www.amazon.com/gp/product/0132350882/ref=s9_simi_gw_s0_p14_i1?pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_s=center-2&amp;pf_rd_r=1K3CYHQKT0B97MR00CNR&amp;pf_rd_t=101&amp;pf_rd_p=470938631&amp;pf_rd_i=507846">libro</a> que hay que llamar a las cosas por su nombre, y esto es básicamente lo que quiere decir esta regla.<br /><br />Revisando mis prácticas de Universidad he observado la tendencia a abreviar todos los nombres de instancias o de métodos, en parte adoptado de un modelo de programación más funcional. Lo que ocurre es que cuando miro dichas prácticas unos años más tarde, ya no se lo que siginifican algunas variables llamadas t o x porque ya no tengo en la cabeza el modelo que estaba tratando en ese momento, pero aún puede resultar peor para una persona que jamas haya trabajado en el dominio del problema que estaba resolviendo.<br /><br /><b>Mantener las clases lo más pequeñas posible.</b><br /><br />En esta regla Jeff Bay indica que las clases no deben tener más de 50 líneas de código y los paquetes no deben tener más de 10 ficheros. No creo que sea un regla que haya que seguir al pie de la letra, supongo que una clase puede tener 60 líneas sin que signifique que no es cohesiva. Pero es bueno que la usemos para preguntarnos si estamos siguiendo el camino correcto, porque una clase cohesiva se limita a una sola cosa y por lo tanto no debería necesitar una gran cantidad de líneas de código para realizar dicha cosa.<br /><br />Nota: Todas estas reglas pueden ser aplicadas en gran cantidad de ocasiones, pero hay que tener claro que habrá momentos en los que no nos conviene o simplemente no podemos hacerlo porque el problema es demasiado complejo, por ejemplo.