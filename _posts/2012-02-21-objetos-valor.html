---
layout: post
title: Objetos valor
date: '2012-02-21T07:45:00.002Z'
author: Yeray Darias
tags: [code, scala, patterns, spanish]
modified_time: '2012-04-20T21:01:57.780+01:00'
---

Vaya, he estado ojeando los borradores acumulados en mi cuenta de Blogger y parece que por aquí había una idea que no estaba mal. No se porque razón no completé este artículo y lo publique, pero como nunca es tarde si la dicha es buena, allá vamos.<br /><br />Hace poco (bueno, ahora ya hace más de año y medio :-) leí un <a href="http://www.krzysztofadamczyk.com/2010/02/the-power-of-value-objects/">artículo</a> de Krzysztof Adamczyk sobre la potencia de hacer uso de objetos valor en nuestro código, y he pensado que podría ser interesante que presente mi propia opinión al respecto de este tema. Para ello tomaré prestadas las ideas del propio Krzysztof Adamczyk y las expuestas por Dan Berg Johnsson en su <a href="http://www.infoq.com/presentations/Value-Objects-Dan-Bergh-Johnsson">presentación</a> en la QCon London 2009.<br /><br /><b>*Nota al lector*</b><br /><br />El siguiente código no es de producción, tan solo es a modo de ejemplo.&nbsp;Está realizado en Scala, pero cualquier persona con conocimientos de Java lo puede entender de forma sencilla.<br /><br /><span style="font-size: large;">¿Qué es un objeto valor?</span><br /><br />Lo mejor será empezar por el principio. Para todos aquellos que no sepan lo que es un objeto valor, Eric Evans define en su <a href="http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1267181356&amp;sr=8-1">libro</a> un objeto valor de la siguiente manera.<br /><blockquote>"An object that represents a descriptive aspect of the domain with no conceptual identity is called a Value Object."</blockquote>He preferido dejarlo en el idioma original porque es posible que yo metiese la pata al hacer la traducción, por lo que con esta definición y lo que cada uno entienda de ella, empezaré con el contenido de esta entrada.<br /><br /><span style="font-size: large;">Los detalles del dominio se hacen explícitos</span><br /><br />Una de las ventajas de hacer uso de los objetos valor, es que en el código desaparecen los tipos como String o int por tipos como PhoneNumber o Email. Aquí muchos pensaréis que esto no es ninguna ventaja sino que añade complejidad, puede ser pero dejadme unos párrafos de ventaja por favor.<br /><br />Imaginad que estamos trabajando en un nuevo y avanzadísimo sistema de gestión ... como por ejemplo, una simple una agenda. Como en cualquier agenda, tendremos un objeto de modelo que define el contacto y generalmente nos encontraríamos con algo similar al siguiente código.<br /><br /><pre class="brush: java">class Contact(val firstName: String, val lastName: String,<br /> val phoneNumber: String) {<br /> <br /> override def toString(): String = {<br />  firstName + " " + lastName + " : " + phoneNumber<br /> }<br />}<br /><br />object Agenda {<br /> <br /> def main(args: Array[String]) = {<br />  val contact = new Contact("Pepe", "García", "922222222")<br />  println(contact)<br /> }<br /> <br />}<br /></pre><br />Genial, muy sencillo, pero ahora imaginemos &nbsp;que nuestro cliente quiere que su agenda indique de forma automática con un icono (que nosotros representaremos en el ejemplo con texto) cuando se trata de un teléfono fijo y cuando de un móvil, por poner un ejemplo. Muchas veces la opción más utilizada es la siguiente.<br /><br /><pre class="brush: java">class Contact(val firstName: String, val lastName: String,<br /> val phoneNumber: String) {<br /> <br /> def phoneNumberType(): String = {<br />  if (phoneNumber.startsWith("6"))<br />   "móvil"<br />  else<br />   "fijo"<br /> }<br /> <br /> override def toString(): String = {<br />  firstName + " " + lastName + " : " + phoneNumber + <br />   " (" + phoneNumberType + ")"<br /> }<br />}<br /><br />object Agenda {<br /> <br /> def main(args: Array[String]) = {<br />  val pepe = new Contact("Pepe", "García", "922222222")<br />  println(pepe)<br />  val juan = new Contact("Juan", "Juanez", "633445566")<br />  println(juan)<br /><br /> }<br /> <br />}<br /></pre><br />Pero ¿qué ocurriría si hiciésemos esto otro?.<br /><br /><pre class="brush: java">class PhoneNumber(val phoneNumber: String) {<br /><br /> def withType(): String = {<br />  phoneNumber + " (" + phoneType + ")"<br /> }<br /> <br /> private def phoneType(): String = {<br />  if (phoneNumber.startsWith("6"))<br />   "móvil"<br />  else<br />   "fijo"<br /> }<br /> <br />}<br /><br />class Contact(val firstName: String, val lastName: String,<br /> val phoneNumber: PhoneNumber) {<br /> <br /> override def toString(): String = {<br />  firstName + " " + lastName + " : " + phoneNumber.withType<br /> }<br /> <br />}<br /><br />object Agenda {<br /> <br /> def main(args: Array[String]) = {<br />  val pepePhone = new PhoneNumber("922222222")<br />  val pepe = new Contact("Pepe", "García", pepePhone)<br />  println(pepe)<br />  val juanPhone = new PhoneNumber("633445566")<br />  val juan = new Contact("Juan", "Juanez", juanPhone)<br />  println(juan)<br /><br /> }<br /> <br />}<br /></pre><br />Ciertamente son bastantes más líneas de código, pero ¿qué hay de la limpieza? y aún más importante, de esta manera se cumple la regla que dice que cada elemento debe tener una única responsabilidad. Ahora la clase Contact no tiene lógica sobre la forma en la que se muestra el número de teléfono.<br /><br />Al tratarse de un ejemplo hemos metido lógica de la vista en el modelo, pero en un caso real lo que haríamos es tener un método en PhoneNumber que nos indique de que tipo de dispositivo se trata, y ya se encargará la capa de la vista de representarlo.<br /><br /><span style="font-size: large;">El código se extiende más fácilmente</span><br /><br />Sigue sin parecerte nada especial y la legibilidad del código no te importa mucho, aunque debería. Pues otra ventaja es que el código se extiende más fácilmente y de manera comprensible. Imagina que ahora queremos saber qué números de teléfono tienen errores, pues basta con que añadamos dicha funcionalidad en el propio objeto PhoneNumber, sin seguir complicando otras clases ni desperdigar la lógica por el resto de la aplicación.<br /><br />Para acabar me gustaría señalar como de esta manera hemos evitado tener un <a href="http://martinfowler.com/bliki/AnemicDomainModel.html">modelo anémico</a>. Es muy usual que se creen modelos como si fueran simples CRUD y luego se reparta cierta lógica en validadores y helpers, ¿no es más lógico que sea el propio objeto el que tenga la lógica que le afecta únicamente a él?<br /><br /><br /><br />