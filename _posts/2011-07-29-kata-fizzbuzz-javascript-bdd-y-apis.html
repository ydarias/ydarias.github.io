---
layout: post
title: 'Kata FizzBuzz: Javascript, BDD y APIs fluidas'
date: '2011-07-29T00:28:00.001+01:00'
author: Yeray Darias
tags: [code, tdd, spanish]
modified_time: '2011-07-29T00:29:07.059+01:00'
---

Durante el día de hoy he tenido algo de tiempo libre y he decidido hacer la Kata FizzBuzz. Algunos os preguntareis, ¿y qué es es eso de la Kata FizzBuzz?, es más ¿qué es una Kata?. ¿Eso no es algo de Karate?. Pues sí, en muchas artes marciales se practican Katas para interiorizar una serie de movimientos preestablecidos, es decir que los aprendamos de manera tan automática que salgan solos. En el desarrollo de software se puede hacer lo mismo practicando con algunos problemas sencillos, lo importante no es resolver el problema en si mismo sino interiorizar una serie de buenas prácticas mientras lo resolvemos (TDD, refactorización, etc).<br /><br />La Kata FizzBuzz en concreto es un problema MUY sencillo, que se puede ver en este <a href="http://codingkata.org/katas/unit/fizz-buzz">enlace</a>. A grandes rasgos lo único que hay que hacer es crear una programa que dado un número se comporte de la siguiente manera.<br /><br /><ul><li>Devuelve fizz si el número es divisible por 3.</li><li>Devuelve buzz si el número es divisible por 5.</li><li>Devuelve fizzbuzz si el número es divisible por 3 y por 5.</li></ul><br />Hay otras variantes en las que se pide escribir un programa que te devuelva el resultado para los primeros 100 número enteros, pero nos quedaremos con lo que he explicado anteriormente, porque esa variante no añade mucho valor a lo que queremos aprender.<br /><br />Para resolver el problema yo he seleccionado Javascript como lenguaje de programación, ¿por qué?, pues porque es una herramienta que cada vez tengo que utilizar más y no domino ni lo más mínimo, incluso se puede decir que no tengo ni idea de Javascript, por eso en mi caso es un lenguaje interesante para hacer una Kata. Como framework de test en Javascript he elegido Jasmine porque ya he usado <a href="http://docs.jquery.com/Qunit">Qunit</a> anteriormente y quería utilizar una aproximación más BDD (no explicaré como funciona ni como instalarlo porque en la <a href="http://pivotal.github.com/jasmine/">web</a> ya lo hacen maravillosamente, si alguien tiene dudas por supuesto puede preguntar).<br /><br />Para los que no lo sepan, BDD son las siglas de Behaviour Driven Development. Yo soy de esos desarrolladores que piensan que TDD y BDD son el mismo perro con distinto collar, solo cambia la forma en la que enuncias los test, pero en la práctica no cambia mucho los pasos que realizas (siempre depende de cada desarrollador), por no decir que no cambian nada. Jasmine es un framework BDD porque enuncia los tests como Specs, es decir que en vez de llamarse test utiliza la construcción describe-it al estilo de RSpec. Puedes comprobarlo en mi solución, que llegó a las siguientes especificaciones.<br /><br /><br /><pre><code><br />describe("FizzBuzzCalculator", function() {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>it("should return 0 with input 0", function() {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>expect(FizzBuzzCalculator.calculate(0)).toEqual(0);<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>});<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>it("should return fizz with input 3", function() {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>expect(FizzBuzzCalculator.calculate(3)).toEqual('fizz');<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>});<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>it("should return buzz with input 5", function() {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>expect(FizzBuzzCalculator.calculate(5)).toEqual('buzz');<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>});<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>it("should return fizz with input 6", function() {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>expect(FizzBuzzCalculator.calculate(6)).toEqual('fizz');<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>});<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>it("should return input when input is not divisible by 3 or 5 (2 == 2)", function() {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>expect(FizzBuzzCalculator.calculate(2)).toEqual(2);<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>});<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>it("should return buzz with input 10", function() {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>expect(FizzBuzzCalculator.calculate(10)).toEqual('buzz');<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>});<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>it("should return fizzbuzz with input 15", function() {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>expect(FizzBuzzCalculator.calculate(15)).toEqual('fizzbuzz');<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>});<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>it("should return fizzbuzz with input 30", function() {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>expect(FizzBuzzCalculator.calculate(30)).toEqual('fizzbuzz');<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>});<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br />});</code><code></code></pre><br /><br />Una de las cosas que se pueden observar con estos tests es que he intentado ir muy poco a poco, triangulando en todos los casos. ¿Qué es eso de triangular?, muy sencillo, cuando me encontraba por ejemplo con el caso "should return fizz with input 3", en la implementación hacía que devolviese 3 de forma directa, y luego creaba otro test "should return fizz with input 6" que me llevaba a "descubrir" la función isDivisibleByThree.<br /><br />Si te fijas, el primer test que realicé fue la comprobación que devuelve cero ante la entrada cero, pero luego seguí por la entrada tres que debe devolver fizz. No fue hasta el cuarto test cuando me di cuenta que si el número no era divisible por 3 ni por 5 debía devolver el propio número. Hasta ese momento solo devolvía cero para todos los casos. He ahí la importancia de tener una libreta con los tests que se deben pasar y anotar todos los nuevos tests que vayan apareciendo. Yo anote dicho test y continué hasta llegar a una solución que me convencía.<br /><br /><br /><pre><code><br />FizzBuzzCalculator = &nbsp;{<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>calculate : function(input) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if (input == 0)<span class="Apple-tab-span" style="white-space: pre;"> </span>return 0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if (isDivisibleByTrhee(input) &amp;&amp; isDivisibleByFive(input)) return 'fizzbuzz';<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if (isDivisibleByThree(input)) return 'fizz';<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if (isDivisibleByFive(input)) return 'buzz';<br /><span class="Apple-tab-span" style="white-space: pre;">  </span><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return input;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>function isDivisibleByTrhee(input) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return input % 3 == 0;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>function isDivisibleByFive(input) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return input % 5 == 0;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br />}</code><code></code></pre><br /><br />Buscando lo que había hecho otra gente encontré un <a href="http://jacegu.eu/diseno-2/4-versiones-de-la-kata-fizz-buzz/">enlace</a> al blog de Javier Acero, recomiendo la lectura porque comenta la importancia del diseño orientado a objetos y se ve como extrae las comprobaciones de la divisibilidad a otra clase. Pues claro!!! se me tenía que haber pasado a mi por la cabeza. Esos son el tipo de detalles que hay que tener en cuenta en una Kata. Se me ocurrió que era buen momento para aprender a hacer APIs fluidas en Javascript y llegue a esta nueva solución, comprobando que pasaba todos los tests que ya pasaban antes.<br /><br /><br /><pre><code><br />var number = function(val) {<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>var operations = {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>_val: val,<br /><span class="Apple-tab-span" style="white-space: pre;">  </span><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>isDivisibleBy: function(divisor) {<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>return this._val % divisor == 0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>return operations;<br />}<br /><br />FizzBuzzCalculator = &nbsp;{<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>calculate : function(input) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if (input == 0)<span class="Apple-tab-span" style="white-space: pre;"> </span>return 0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if (number(input).isDivisibleBy(3) &amp;&amp; number(input).isDivisibleBy(5)) return 'fizzbuzz';<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if (number(input).isDivisibleBy(3)) return 'fizz';<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if (number(input).isDivisibleBy(5)) return 'buzz';<br /><span class="Apple-tab-span" style="white-space: pre;">  </span><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return input;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><span class="Apple-tab-span" style="white-space: pre;"> </span><br />}</code><code></code></pre><br /><br />Quizás la "clase" number no es tan clara como se espera (puede que sea por mi ignorancia en Javascript), pero desde luego de cara a los usuarios de nuestra API tener líneas como<br /><br /><br /><pre><code><br />if (number(input).isDivisibleBy(5)) return 'buzz'</code><code></code></pre><br /><br />es más claro que el agua :-)<br /><br />Bueno no he explicado lo que es una API fluida, ¿no lo has averiguado tú solo?, pues se trata de una API en la que se componen las llamadas a los métodos de manera consecutiva, es decir llamamos a number(input) y seguidamente podemos llamar a isDivisibleBy(5) de forma que se puede leer todo junto y se entiende que se quiere comprobar que es input el que tiene que ser divisible por 5 :-D ¿Está más claro ahora? Por ejemplo en Java, JodaTime es un buen ejemplo de API fluida.<br /><br /><br /><pre><code><br />public boolean isRentalOverdue(DateTime datetimeRented) {<br />&nbsp; Period rentalPeriod = new Period().withDays(2).withHours(12);<br />&nbsp; return datetimeRented.plus(rentalPeriod).isBeforeNow();<br />}</code><code></code></pre><br /><br />Espero que os haya gustado y que hagáis todas las críticas (constructivas) buenas o malas que merezca :-D el debate es lo interesante.